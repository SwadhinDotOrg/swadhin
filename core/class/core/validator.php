<?php

/* * ***** ****** ****** ****** ****** ******
 *
 * Author       :   Shafiul Azam
 *              :   ishafiul@gmail.com
 *              :   Project Manager
 * Page         :
 * Description  :   
 * Last Updated :
 *
 * ****** ****** ****** ****** ****** ***** */

/**
 * \brief Validates user-submitted inputs.
 *
 * \note In controller classes, you can get an object of this class writing: $this->validate
 * 
 * Functions of this class are heavily used in validating web-forms.
 * 
 * Most of the functions (except userInput() ) of this class are used form validation. But, you can apply these 
 * functions for validating any string. 
 * 
 * You can add your own validation-functions in custom/class/Validator.php file.
 * 
 * <b>How to use:</b>
 * 
 * The string on which these validation operations will take 
 * place should be first stored in member variable $this->subject. Then you can call one/more member functions.
 * 
 * If any function failed by returning false, an error message will be appended to member variable $this->errorArray <i>(automatically)</i>.
 * 

 * 
 * \see Link to Tutorial: 
 */

class CoreValidator{
    
    public $subject;    ///<    The string on which validation functions will operate.
    public $errorArray; ///<    Array to store error strings generated by various validation functions.
    public $form;       ///<    A reference to the form it is currently processing (if any)        
    // Vars for internal use
    private $core = null;  ///< Reference to the $core object   
    private $redirectURL = "";  ///<    URL to redirect if validation fails.
   
    // Constructors
    
    /**
     * You should (recommended) pass the $core as parameter
     * @param Core object $core pass $core here 
     */
    
    
    public function __construct($core=null) {
        $this->core = $core;
        $this->errorArray = array();
    }
    
    /**
     * Used to get user-submitted data. You can get data send by GET/POST methods.
     * 
     * This function does some common validation check like removing all %HTML symbols (thus preventing XSS attack), 
     * checking maximum character limit for input, checking whether the field is required etc.
     * 
     * <b>You should always use this function to get user submitted data!</b>
     * 
     * \note This function appends error message to $errorArray
     * 
     * @param string $data | string to validate (subject)
     * @param int $length maximum length the subject might be. Infinity if parameter empty
     * @param bool $required if true, validation fails if subject is empty
     * @param string $defaultValue a default value to return if the subject is empty, only applicable when $required is false
     * @return mixed 
     * - bool | false if validation fails.
     * - validated string, passed through php's htmlspecialchars
     */
    
    public function input($data, $length="", $required = true, $defaultValue = "") {
        if ($required) {
            if (empty($_REQUEST["$data"])) {
                $this->core->funcs->messageExit('Required field <b>' . $data . '</b> is empty!', MSGBOX_ERROR, $this->redirectURL);
            } else if (!empty($length) && strlen($_REQUEST["$data"]) > $length) {
                $this->core->funcs->messageExit('Required field <b>' . $data . '</b> is too large! (Max <b>' . $length . '</b> chars allowed).', MSGBOX_ERROR, $this->redirectURL);
            }
        }
        $return = (empty($_REQUEST[$data])) ? ($defaultValue) : (htmlspecialchars($_REQUEST["$data"]));
        return $return;
    }
    
    /**
     * Get all the error strings generated (if any) so far.
     * 
     * When you call one/more validation functions on $subject, error strings are stored if any validation fails. 
     * This function will return all the error strings joined by <b>$joiner</b>
     * 
     * @param string $joiner - default: <i>< br / ></i>
     * @return 
     *  - string | error messages joined by $joiner if any of the validation functions failed
     *  - empty string if no error message is available.
     */
    
    public function getError($joiner = "<br />"){
        $errorString = '';
        $errorString = implode($joiner,$this->errorArray);
        $this->errorArray = array(); //  Reset the error Array.
        return $errorString;
    }
    
    /**
     * If any validation fails, this function will redirect to $this->redirectURL
     * 
     * When you call one/more validation functions on $subject, error strings are stored if any validation fails. 
     * This function will join all the error strings by <b>$joiner</b>. Then it may redirect or just return the error
     * string based on argument <b>$exit</b>
     * 
     * @param bool $exit | set to true if you want to redirect to $this->redirectURL - if validation fails
     * @param string $joiner the string used to join all error messages.
     * @return mixed
     *  - if any of the validation fails 
     *      -   string | error string if parameter $exit is set to false
     *      -   none | redirects to $redirectURL if $exit set to true
     *  - if none of the validation fails
     *      -   bool false : CHECK THIS!  
     * 
     * \warning This function returns <b>false</b> if all validations were successful!
     */
    
    public function exitIfInvalid($exit=true, $joiner = "<br />"){
        // if exit = false, just returns the error string if there are errors. Returns FALSE if valid!
        $errorString = '';
        $errorString = implode($joiner,$this->errorArray);
        $this->errorArray = array();    //  Reset the error Array.
        if(!empty($errorString)){
            if($exit){
                $this->core->funcs->messageExit($errorString, MSGBOX_ERROR, $this->redirectURL);
            }
            return $errorString;
        }else{
            return false;   //  Returns false if valid!
        }
    }
    
    
    
    
    
    /**
     * @name Validation Functions
     */

    //@{
    
    
    
    /**
     * Checks if $this->subject is one of the values specified by $possibleValues
     * 
     * @param string $possibleValues all the possible values of $this->subject, each seperated by a colon (:) character
     * 
     *  -   example: if $possibleValues is: "male:female" then $this->subject should be either "male" or "female"
     *  -   If you have some value which itself has colon (:) in it, escape all colons with a preceeding slash (\)
     * @return bool - false if validation fails, else returns true
     */
    
    public function enum($possibleValues){
        // Handle escaped
        $possibleValues = str_replace("\:", "-_-_-", $possibleValues);
        // Get arrays for possible values
        $possibleValuesArr = explode(":", $possibleValues);
        // Handle escaped
        $values = array();
        foreach($possibleValuesArr as $i)
            $values[] = str_replace ("-_-_-", ":", $i);
        if(!in_array($this->subject, $values)){
            $this->errorArray[] = "is not a valid value";
            return false;
        }
        return true;
    }
    
    
    /**
     * Validates whether $subject is a valid Email address
     * @return bool false if invalid, true else.
     */
    
    public function email() {
        if( !preg_match('|^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,3})$|i', $this->subject) ){
            $this->errorArray[] = "is not a valid email";
            return false;
        }
        return true;
                
    }
    
    /**
     * Replaces non alpha-numeric charecters from $subject. 
     * \note Does not generate any error message. 
     * @param string $replaceWith - the character with which non alphanumeric chars will be replaced
     * @return None
     */
    
    public function replaceNonAlphaNumerics($replaceWith = "-") {
        $this->subject =  preg_replace("@[^A-Za-z0-9]@", $replaceWith, $this->subject);
    }
    
    /**
     * @return bool false : if $subject is empty
     */
    
    public function required(){
        if(empty($this->subject)){
            $this->errorArray[] = "can not be empty";
            return false;
        }
        return true;
    }
    
    /**
     * Applies PHP's built in htmlspecialchars function
     */
    
    public function htmlspecialchars(){
        // No error is generated, just filters the text
        $this->subject = htmlspecialchars($this->subject);
    }
    
    /**
     * Checks if member variable $subject is equal to 1st parameter $compareWith 
     * @param string $compareWith subject is compared with this parameter
     * @param string $errorMessage the error message to display if comparison fails
     * @return bool | false if validation fails 
     */
    
    public function equalsToStr($compareWith, $errorMessage=""){
        if($this->subject != $compareWith){
            if(empty($errorMessage))
                $errorMessage = "comparison failed";
            $this->errorArray[] = $errorMessage;
            return false;
        }
        return true;
    }
    
    /**
     * Checks if member variable $subject is equal to the user provided value for form element with $elementName name attribute  
     * @param string $elementName name attribute of form element. With the user povided value for this element, $this->subject will be compared.
     * @return bool | false if validation fails 
     */
    
    public function equalsToElement($elementName){
        // get the desired element's user submitted value.
        $compareWith = $this->form->get($elementName);
        if($this->subject != $compareWith){
            $compareWithDisplayName = $this->form->getDisplayName($elementName);
            $this->errorArray[] = "does not match with form element &quot;$compareWithDisplayName&quot;";
            return false;
        }
        return true;
    }
    
    /**
     * Checks if member variable $subject is withing upper & lower character limit
     * @param int $minimumChars minimum length $this->subject should be of
     * @param int $maximumChars maximum length $this->subject can be of
     * @return boolean false if validation fails, true otherwise
     */
    
    public function limit($minimumChars = "", $maximumChars = ""){
        $errorOccured = false;
        if(!empty($minimumChars)){
            if(strlen($this->subject) < $minimumChars){
                $this->errorArray[] = "should be at least $minimumChars character(s)";
                $errorOccured = true;
            }
        }
        if(!empty ($maximumChars)){
            if(strlen($this->subject) > $maximumChars){
                $this->errorArray[] = "can be at most $maximumChars character(s)";
                $errorOccured = true;
            }
            
        }
        return $errorOccured;
    }
    
    public function int(){
        $pattern = '@[\D]@';
        if(preg_match($pattern, $this->subject) !== 0){
            $this->errorArray[] = "is not an integer.";
            return false;
        }
        return true;
    }
    
    public function alphanumeric(){
        $pattern = '@[^\w-]@i';
        if(preg_match($pattern, $this->subject) !== 0){
            $this->errorArray[] = "is not an alphanumeric, only letters, digits, underscore & hyphen are allowed.";
            return false;
        }
        return true;
    }


    /**
     * Always return true.
     * @return type 
     */
    
    public function dummy(){
        return true;
    }
    
    //@}
    
    
    
}

?>